#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

////程序1 指针的定义
////32位的指针大小为4字节
////64位的指针大小为8字节
//int main()
//{
//	int a = 10;	//a占4个字节
//	int* pa = &a;//拿到的是a的4个字节中的第一个字节的地址
//	*pa = 20;
//	printf("%d\n", a);
//
//	return 0;
//}

////程序2 指针和指针类型
//int main()
//{
//	////引子
//	//int* pa;
//	//char* pc;
//	//float* pf;
//	//printf("%d\n", sizeof(pa));//4
//	//printf("%d\n", sizeof(pc));//4
//	//printf("%d\n", sizeof(pf));//4
//
//	//意义
//	//1.指针类型决定了：指针解引用的权限有多大
//	//2.指针类型决定了：指针走一步能走多远（距离）
//	
//	//1
//	//补充(16进制的组成)：0 1 2 3 4 5 6 7 8 9 a b c d e f
//	//int a = 0x11223344;
//	//int* pa = &a;
//	//*pa = 0;//改了4个字节
//	////char* pc = &a;
//	////*pc = 0;//只改了1个字节，而且报了警告
//
//	//2
//	int arr[10] = { 0 };
//	int* p = arr;
//	char* pc = arr;	//都存了首元素地址
//
//	printf("%p\n", p);
//	printf("%p\n", p + 1);	//上面跨度4个字节
//
//	printf("%p\n", pc);
//	printf("%p\n", pc + 1);//上面跨度1个字节
//
//	return 0;
//}

////程序3 应用
//int main()
//{
//	int arr[10] = { 0 };
//	/*char* p = arr;*/
//	int* p = arr;
//	for (int i = 0; i < 10; i++)
//		*(p + i) = 1;
//	for (int i = 0; i < 10; i++)
//		printf("%d ", arr[i]);
//
//	return 0;
//}

////程序4 野指针 -- 指针指向的位置是不可知的
////原因：
////1.指针没有初始化
////2.指针越界访问
////3.指针指向的空间释放 ―― 就是空间的生命周期结束了，但指针还是指向这个空间
////解决方法：
////1.指针初始化（NULL，0，明确的值）
////2.小心指针越界（c语言不会检查数组越界行为）
////3.指针指向空间释放即放置NULL ―― 0
////4.指针使用之前检查有效性（初始化为NULL时，不可以使用，因为NULL不属于系统和用户的空间）
//int* test()
//{
//	int a = 10;
//	return &a;
//}
//int main()
//{
//	////1
//	//int* p;//p是一个局部的指针变量，局部变量不初始化的话，默认是随机值
//	//*p = 20;//非法访问内存
//
//	////2
//	//int arr[10] = { 0 };
//	//int* p = arr;
//	//int i = 0;
//	//for (i = 0; i <= 10; i++)
//	//{
//	//	*p = i;
//	//	p++;	//p=10时就越界
//	//}
//
//	//3
//	int* p = test();
//	*p = 20;//a已经释放了，强行放就会造成野指针
//
//	return 0;
//}

////程序5 指针运算
////1.指针 + - 整数
////2.指针 - 指针	―― 指针之间的元素个数(指针 + 指针 没有意义)
////3.指针的关系运算（比较大小）
//#define N_VALUES 5
//#include <string.h>
//int main()
//{
//	////1，3
//	//float values[N_VALUES];
//	//float* vp;
//	////指针+-整数；指针的关系运算
//	//for (vp = &values[0]; vp < &values[N_VALUES];)
//	//{
//	//	*vp++ = 0;
//	//}
//
//	////1，3 例子
//	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	//int* p = arr;
//	//int* pend = arr + 9;
//	//while (p <= pend)
//	//{
//	//	printf("%d\n", *p);
//	//	p++;
//	//}
//
//	////2
//	////相减的前提是两个指针指向同一块空间
//	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	//printf("%d\n", &arr[9] - &arr[0]);//得出的结果是指针之间的元素个数 9
//
//	//2 例子
//	int my_strlen();
//	int len = my_strlen("abc");
//	printf("%d\n", len);
//
//	////3
//	//float values[N_VALUES];
//	//float* vp;
//	////有问题的：
//	//for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--)
//	//{
//	//	*vp = 0;
//	//}
//	////标准规定：
//	////允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许
//	////与指向第一个元素之前的那个内存位置的指针进行比较。
//	////
//	////虽然实际在绝大部分的编译器上是可以顺利完成任务的，但是我们还是应该避免这样写，因为标准并
//	////不保证它可行。
//	////没有问题的：
//	//for (vp = &values[N_VALUES]; vp > &values[0];)
//	//{
//	//	*--vp = 0;
//	//}
//
//	return 0;
//}
//////1.计数器
////int my_strlen(char* str)
////{
////	int count = 0;
////	while (*str != '\0')
////	{
////		count++;
////		str++;
////	}
////	return count;
////}
//////2.递归
////int my_strlen(char* str)
////{
////	if (*str == '\0')
////		return 0;
////	else
////		return 1 + my_strlen(str + 1);
////}
////3.指针 - 指针
//int my_strlen(char* str)
//{
//	char* start = str;
//	while (*str != '\0')
//		str++;
//	return str - start;
//}

////程序6 指针和数组
//int main()
//{
//	////引子
//	//int arr[10] = { 0 };//数组名是数组首元素地址
//	//printf("%p\n", arr);
//	//printf("%p\n", &arr[0]);
//	//printf("%p\n", &arr);
//	//printf("――――――――――――――――――――\n");
//
//	//int* p = arr;
//	//int i = 0;
//	//for (i = 0; i < 10; i++)
//	//{
//	//	//printf("%p <==> %p\n", &arr[i], p + i);
//	//	*(p + i) = i;
//	//	printf("%d ", *(p + i));
//	//}
//
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* p = arr;
//	//arr[2]  <==>  *(p + 2)  <==>  *(arr + 2)  <==>  *(2 + p)  <==>  *(2 + arr)
//	//arr[2]  <==>  2[arr]
//	//[] 是一个操作符  2和arr是两个操作数
//	printf("%d\n", 2[arr]);	//2[arr] --> *(2 + arr)
//	printf("%d\n", arr[2]);	//arr[2] --> *(arr + 2)
//	printf("%d\n", p[2]);	//p[2] --> *(p + 2)  同理也是可以的
//	printf("%d\n", 2[p]);	//2[p] --> *(2 + p)  同理也是可以的
//							//程序可以运行，结果一样,都是 3
//
//	return 0;
//}

////程序7 二级指针
//int main()
//{
//	int a = 10;
//	int* pa = &a;	//pa是指针变量，一级指针
//	int** ppa = &pa;//pa也是个变量，&pa取出pa在内存中起始地址
//					//第一个*是告诉ppa是指针，指向pa，第二个*告诉pa的类型是int*
//					//ppa就是一个二级指针变量
//	int*** pppa = &ppa;//三级指针
//
//	return 0;
//}

//程序8 指针数组 -- 数组
int main()
{
	int arr[10];//整型数组 - 存放整型的数组就是整型数组
	char ch[5];//字符数组 - 存放字符的数组就是字符数组
	//指针数组 - 存放指针的数组就是指针数组
	int* parr[5];//整型指针的数组
	char* ch[5];//字符指针的数组

	return 0;
}