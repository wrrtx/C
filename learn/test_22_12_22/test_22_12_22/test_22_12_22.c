#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

////程序1 赋值操作符 = += -= /= %= *= >>= <<= 等等
//int main()
//{
//	int a = 10;
//	a = 100;
//	a += 100;
//	a >>= 3;
//	// =   ――  赋值
//	// ==  ――  判断
//
//	return 0;
//}

////程序2 单目操作符 ! + - & sizeof ~ -- ++ * (类型)
////只有一个操作数
//int main()
//{
//	////!逻辑反操作符
//	//int flag = 5;
//	//printf("%d\n", !flag);
//	//if (flag)//flag为真打印
//	//	printf("hehe\n");
//	//if (!flag)//flag为假打印
//	//	printf("haha\n");
//
//	////+正值 -负值
//	//int a = 10;
//	//a = -a;
//
//	////sizeof操作数的类型长度（字节为单位）
//	////指针是地址，永远都是32/64位比特，所以无论类型是什么，都是4个字节
//	//int a = 10;
//	//int arr[10] = { 0 };
//	//printf("%d\n", sizeof(a));	//与下面一致
//	//printf("%d\n", sizeof(int));
//	//printf("%d\n", sizeof a);	//此处证明sizeof是一个操作符，不是函数
//	//printf("%d\n", sizeof(arr));//arr是char时为10
//	//printf("%d\n", sizeof(arr));//arr是int时为40
//	//printf("%d\n", sizeof(int [10]));//40	int [10]是arr数组类型
//
//	////小题目
//	//short s = 5;
//	//int a = 10;
//	//printf("%d\n", sizeof(short));//short占用2个字节
//	//printf("%d\n", sizeof(s = a + 2));//2	依旧是short类型
//	//printf("%d\n", s);				  //5	在sizeof括号的表达式不参与运算的
//	//								  //可以理解为sizeof内部只是一个判断条件，不影响判断的数
//
//	////~对一个数的二进制按位取反
//	//int a = -1;
//	////10000000000000000000000000000001 - 原码
//	////11111111111111111111111111111110 - 反码
//	////11111111111111111111111111111111 - 补码
//	////~按位取反
//	////00000000000000000000000000000000
//	//int b = ~a;
//	//printf("%d\n%d", a, b);//a=-1,b=0
//
//	////++ 前置、后置++  -- 前置、后置--
//	//int a = 10;
//	//int b = a++;//后置++   先使用，后++		即b=10,a=11
//	//printf("%d\n%d\n", a, b);
//	//int c = ++a;//前置++   先++，后使用		即c=12,a=12
//	//printf("%d\n%d\n", a, c);
//	//printf("%d %d", c--, c);//12 11
//	
//	//&取地址 *间接访问操作符
//	int a = 10;
//	printf("%p\n", &a);	//取地址
//	int* pa = &a;	//pa是用来存地址的，pa是一个指针变量
//	*pa = 20;		//*解引用操作符（间接访问操作符）
//	printf("%d %d\n", *pa, a);//20 20
//
//	//(类型)强制类型转换
//	int d = (int)3.14;
//
//	return 0;
//}

////程序3 关系操作符 > >= < <= != ==
//// =   ――  赋值
//// ==  ――  判断
////比较两个字符串相等一定不能用 ==
//int main()
//{
//	int a = 3;
//	int b = 5;
//	if (a == b);
//	if (a != b);
//	if (a <= b);
//
//	return 0;
//}

////程序4 逻辑操作符 && ||
//int main()
//{
//	int a = 3;
//	int b = 0;
//	if (a && b);
//	if (a || b);
//
//	return 0;
//}

////程序5 计算a,b,c,d的值，补充逻辑操作符的知识点
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;	// && 当a为假时就直接结束了，后面不算
//	i = a++||++b||d++;			// || 一直找到一个真的就结束，后面不算
//	printf("a = %d\nb = %d\nc = %d\nd = %d\ni = %d", a, b, c, d, i);
//
//	return 0;
//}

////程序6 条件操作符（三目操作符）exp1 ? exp2 : exp3
//int main()
//{
//	int a = 3;
//	int b = 0;
//	if (a > 5)
//		b = 1;
//	else
//		b = -1;
//	printf("1.%d\n", b);
//
//	//三目操作符
//	b = (a > 5 ? 1 : -1);
//	printf("2.%d\n", b);
//
//	return 0;
//}

////程序7 逗号表达式 exp1, exp2, exp3, …expN
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = 0;
//	int x = 1, y = 2, z = 3;
//	//逗号表达式――从左往右依次计算，但整个表达式的结果是最后一个表达式的结果
//	int d = (c = 5, a = c + 3, b = a - 4, c += 5);
//	//       c=5,a=8,b=4,c=10
//	printf("%d\n", d);//10
//
//	return 0;
//}

////程序8 下标引用 []
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%d\n", arr[4]);	//下标引用操作符，操作数2个：arr，4
//
//	return 0;
//}

////程序9 函数调用 ()
//int add(int x, int y)
//{
//	return x + y;
//}
//void test()
//{ }
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数
//	int ret = add(a, b);	//操作数3个
//	printf("%d\n", ret);
//	test();
//
//	return 0;
//}

////程序10 结构成员 . ->
////.   结构体.成员名
////->  结构体指针->成员名
//struct book
//{
//	//结构体成员变量
//	char name[20];
//	char id[20];
//	double price;
//};
//int main()
//{
//	struct book b = { "c语言","c20221222",19.39 };
//	//1
//	printf("书名：%s\n", b.name);
//	printf("书号：%s\n", b.id);
//	printf("定价：%.2f\n", b.price);
//
//	//2
//	struct book* pb = &b;
//	printf("书名：%s\n", (*pb).name);
//	printf("书号：%s\n", (*pb).id);
//	printf("定价：%.2f\n", (*pb).price);
//
//	//3
//	printf("书名：%s\n", pb->name);
//	printf("书号：%s\n", pb->id);
//	printf("定价：%.2f\n", pb->price);
//
//	return 0;
//}

////程序11 隐式类型转换 ―― 整型提升
////有符号位的高位补符号位，没有的高位补0
////小于4个字节的都要提升
//int main()
//{
//	char a = 3;
//	//00000000000000000000000000000011
//	//00000011 - a
//	char b = 127;
//	//00000000000000000000000001111111
//	//01111111 - b
//	char c = a + b;
//	//a，b提升后：(按照符号位提升)
//	//00000000000000000000000000000011
//	//00000000000000000000000001111111
//	//相加后：
//	//00000000000000000000000010000010
//	//放到char后：
//	//10000010 - c
//	//a,b都是char类型，都没达到int的大小，发生整型提升
//
//	//c打印的是整型，再次发生整型提升
//	//11111111111111111111111110000010 - 提升后的结果，但这个是补码
//	//11111111111111111111111110000001 - 反码 - 补码-1再按位取反
//	//10000000000000000000000001111110 - 原码
//	printf("%c\n%d\n%c\n%d\n", a, a, b, b);
//	printf("%c\n", c);//c=?
//	printf("%d\n", c);//c=-126
//
//	return 0;
//}

////程序12 整型提升的例子
//int main()
//{
//	////1
//	//char a = 0xb6;
//	//short b = 0xb600;
//	//int c = 0xb6000000;
//	//if (a == 0xb6)
//	//	printf("a");
//	//if (b == 0xb600)
//	//	printf("b");//a，b都会整型提升，所以不同
//	//if (c == 0xb6000000)
//	//	printf("c");
//
//	//2
//	//%u是打印无符号数
//	char c = 1;
//	printf("%u\n", sizeof(c));	//1
//	printf("%u\n", sizeof(+c));	//4
//	printf("%u\n", sizeof(-c));	//4
//	printf("%u\n", sizeof(!c));	//1，这里应该也是4(gcc一定是4)，但编译器标准不同
//
//	return 0;
//}

////程序13 算术转换
////由低到高转换
////long double
////double
////float
////unsigned long int
////long int
////unsigned int
////int
//int main()
//{
//	int a = 4;
//	float f = 4.5f;
//	a + f;//a变成float类型
//
//	return 0;
//}

//程序14 操作符的属性
//复杂表达式的求值有三个影响的因素。
//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序
int main()
{
	int a = 4;
	int b = 5;
	int c = a + b * 7;//优先级决定了计算顺序
	c = a + b + 7;//优先级不起作用，结合性决定了顺序

	return 0;
}