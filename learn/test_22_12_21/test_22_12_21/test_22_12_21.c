#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

////程序1 算术操作符 + - * / %
//int main()
//{
//	//除法'/'
//	int a = 6 / 5;//整数除法
//	float b = 6.0f / 5.0;//得到1,要小数的话至少要有一个浮点数，如6.0或者5.0
//					  //有警告是因为6.0判断为double类型，后面加个f就可以了，6.0f
//	//取模'%'
//	int c = 7 % 3;//注意，两边都一定要是整型
//	printf("%d\n", a);
//	printf("%f\n", b);
//	printf("%d\n", c);
//
//	return 0;
//}

////程序2 移位操作符 >> <<
//int main()
//{
//	int a = -1;		//a一直没有变化
//	//把a的二进制位向左移动一位
//	//a的二进制为00000000000000000000000000000010		
//	//       变为00000000000000000000000000000100		
//	//<<左移操作符中：左移的0去掉，右边补个0。左弃右补
//	//>>右移操作符：1算术右移--右边丢弃，左边补原符号位。  当前平台为算术右移
//	//              2逻辑右移--右边丢弃，左边都补0
//    //注：正整数：原码、反码、补码相同。
//    //      负数：原码--直接根据数值写出来的二进制序列
//	//			  反码--原码符号位不变，其他为按位取反
//	//			  补码--反码加1
//	int b = a << 1;//a为2时，b为4。a为-1时，b为-2
//	int c = a >> 1;//a为2时，c为1。a为-1时，c为-1
//	printf("%d\n%d\n", b, c);
//
//	return 0;
//}

////程序3 位操作符 &按位与 |按位或 ^按位异或 
////注意：操作数必须是整数
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//&按(二进制)位与
//	//3：00000000000000000000000000000011
//	//5：00000000000000000000000000000101
//	//   00000000000000000000000000000001  有0就是0，都是1才是1
//	int c = a & b;
//	printf("%d\n", c);//c=1
//
//	//|按(二进制)位或
//	//3：00000000000000000000000000000011
//	//5：00000000000000000000000000000101
//	//   00000000000000000000000000000111  全是0才是0，有1就是1
//	int d = a | b;
//	printf("%d\n", d);//d=7
//
//	//^按(二进制)位异或
//	//3：00000000000000000000000000000011
//	//5：00000000000000000000000000000101
//	//   00000000000000000000000000000110  相同为0，相异为1
//	int e = a ^ b;
//	printf("%d\n", e);//e=6
//
//	return 0;
//}

////程序4 位操作符使用
////交换两个变量不使用第三个变量
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("0:a=%d,b=%d\n", a, b);
//	//1.用第三个变量
//	a = 3, b = 5;
//	int c = 0;
//	c = a;
//	a = b;
//	b = c;
//	printf("1:a=%d,b=%d\n", a, b);
//	//2.加减法（缺陷：数字太大时会溢出）
//	a = 3, b = 5;
//	a = a + b;
//	b = a - b;
//	a = a - b;
//	printf("2:a=%d,b=%d\n", a, b);
//	//3.位操作符:按位异或（没有进位，不会溢出）
//	//00000000000000000000000000000011  a
//	//00000000000000000000000000000101  b
//	//00000000000000000000000000000110  1. a
//	//00000000000000000000000000000011  2.  b
//	//00000000000000000000000000000101  3.   c
//	a = 3, b = 5;
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;	//相当于a ^ b ^ b = a
//	printf("3:a=%d,b=%d\n", a, b);
//
//	//还得出一个结论
//	//a ^ a = 0;
//	//0 ^ a = a;
//
//	return 0;
//}

////程序5 求一个整数存储在内存中的二进制中1的个数
////方法2：
//#include <stdio.h>
//int main()
//{
//	////1
//	//int num = 10;
//	//int count = 0;//计数
//	//while (num)
//	//{
//	//	if (num % 2 == 1)
//	//		count++;
//	//	num = num / 2;
//	//}
//	//printf("二进制中1的个数 = %d\n", count);
//
//	////2
//	//int num = -1;
//	//int i = 0;
//	//int count = 0;//计数
//	//for (i = 0; i < 32; i++)
//	//{
//	//	if (((num >> i) & 1) == 1)
//	//		count++;
//	//}
//	//printf("二进制中1的个数 = %d\n", count);
//	
//	//3
//	int num = -1;
//	int i = 0;
//	int count = 0;//计数
//	while (num)
//	{
//		count++;
//		num = num & (num - 1);
//	}
//	printf("二进制中1的个数 = %d\n", count);
//
//	return 0;
//}

//程序6 加深印象
int main()
{
	int a = 13;
	//把第4个二进制的0变为1
	//00000000000000000000000000001101
	//00000000000000000000000000010000
	//00000000000000000000000000011101
	//
	//1<<4
	//00000000000000000000000000000001
	a = a | (1 << 4);
	printf("%d\n", a);//a=29

	//改回来,用~按位取反
	//00000000000000000000000000011101
	//11111111111111111111111111101111  用这个与上面的，得最下面得
	//00000000000000000000000000010000  1<<4得到这个，用这个按位取反得上面的
	//00000000000000000000000000001101
	a = a & ~(1 << 4);
	printf("%d\n", a);//a=13

	return 0;
}